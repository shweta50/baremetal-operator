package watch

import (
	"context"
	"errors"
	"io/ioutil"
	"os"
	"sync"
	"time"

	log "github.com/sirupsen/logrus"
	"gopkg.in/yaml.v2"

	agentv1 "github.com/platform9/pf9-addon-operator/api/v1"
	"github.com/platform9/pf9-qbert/sunpike/apiserver/pkg/apis/sunpike/v1alpha2"
	"k8s.io/apimachinery/pkg/watch"
	"sigs.k8s.io/controller-runtime/pkg/client"

	appsv1 "k8s.io/api/apps/v1"
	corev1 "k8s.io/api/core/v1"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"

	"k8s.io/apimachinery/pkg/runtime"
	"k8s.io/apimachinery/pkg/types"
	"k8s.io/client-go/kubernetes"
	"k8s.io/client-go/tools/cache"
	"k8s.io/client-go/tools/clientcmd"
)

const (
	resourceFile = "/etc/addon/resources.yaml"
)

var clusterID string
var addonDetails map[string]int64
var lock sync.Mutex

func init() {
	// clusterID is required to query the addon object of name: <clsuuid>-<addon type>
	clusterID = os.Getenv("CLUSTER_ID")
	addonDetails = map[string]int64{}
	lock = sync.Mutex{}
}

// Watch watches resources deployed by addon operator
type Watch struct {
	ctx            context.Context
	client         client.Client
	deploymentInf  cache.SharedIndexInformer
	daemonSetInf   cache.SharedIndexInformer
	statefulSetInf cache.SharedIndexInformer
	configMapInf   cache.SharedIndexInformer
	secretInf      cache.SharedIndexInformer
	serviceInf     cache.SharedIndexInformer

	updatedRes              map[string]bool
	checkRes                map[string]string
	lock                    sync.RWMutex
	watchIntervalSecs       int
	addonChangeIntervalSecs int64
}

// WatchConfig is a map of resources we are expected to watch
type WatchConfig struct {
	Resources map[string]string `yaml:"resources"`
}

// SetAddonOperation is called when an Addon is created / updated / deleted
func SetAddonOperation(addonType string) {
	if addonType == "" {
		return
	}

	// Reconcile loop invokes this function for a valid Addon operation.
	// The ts is stored against the addon type, to ignore events generated by the Addon operator.
	lock.Lock()
	addonDetails[addonType] = time.Now().Unix()
	lock.Unlock()
}

// New returns new instance of watcher
func New(ctx context.Context, cl client.Client) (*Watch, error) {

	cfg, err := clientcmd.BuildConfigFromFlags("", os.Getenv("KUBECONFIG"))
	if err != nil {
		return nil, err
	}

	client, err := kubernetes.NewForConfig(cfg)
	if err != nil {
		return nil, err
	}

	checkRes, err := readResourcesFile()
	if err != nil {
		return nil, err
	}

	log.Infof("Watch: Read resources file, %d entries found", len(checkRes))

	appsV1 := client.AppsV1()
	coreV1 := client.CoreV1()

	//Deployment Informer
	deploymentInf := cache.NewSharedIndexInformer(
		&cache.ListWatch{
			ListFunc: func(options metav1.ListOptions) (runtime.Object, error) {
				return appsV1.Deployments(metav1.NamespaceAll).List(ctx, options)
			},
			WatchFunc: func(options metav1.ListOptions) (watch.Interface, error) {
				return appsV1.Deployments(metav1.NamespaceAll).Watch(ctx, options)
			},
		},
		&appsv1.Deployment{},
		0,
		cache.Indexers{cache.NamespaceIndex: cache.MetaNamespaceIndexFunc},
	)

	//Daemonset Informer
	daemonSetInf := cache.NewSharedIndexInformer(
		&cache.ListWatch{
			ListFunc: func(options metav1.ListOptions) (runtime.Object, error) {
				return appsV1.DaemonSets(metav1.NamespaceAll).List(ctx, options)
			},
			WatchFunc: func(options metav1.ListOptions) (watch.Interface, error) {
				return appsV1.DaemonSets(metav1.NamespaceAll).Watch(ctx, options)
			},
		},
		&appsv1.DaemonSet{},
		0,
		cache.Indexers{cache.NamespaceIndex: cache.MetaNamespaceIndexFunc},
	)

	//Statefulset Informer
	statefulSetInf := cache.NewSharedIndexInformer(
		&cache.ListWatch{
			ListFunc: func(options metav1.ListOptions) (runtime.Object, error) {
				return appsV1.StatefulSets(metav1.NamespaceAll).List(ctx, options)
			},
			WatchFunc: func(options metav1.ListOptions) (watch.Interface, error) {
				return appsV1.StatefulSets(metav1.NamespaceAll).Watch(ctx, options)
			},
		},
		&appsv1.StatefulSet{},
		0,
		cache.Indexers{cache.NamespaceIndex: cache.MetaNamespaceIndexFunc},
	)

	//Configmap Informer
	configMapInf := cache.NewSharedIndexInformer(
		&cache.ListWatch{
			ListFunc: func(options metav1.ListOptions) (runtime.Object, error) {
				return coreV1.ConfigMaps(metav1.NamespaceAll).List(ctx, options)
			},
			WatchFunc: func(options metav1.ListOptions) (watch.Interface, error) {
				return coreV1.ConfigMaps(metav1.NamespaceAll).Watch(ctx, options)
			},
		},
		&corev1.ConfigMap{},
		0,
		cache.Indexers{cache.NamespaceIndex: cache.MetaNamespaceIndexFunc},
	)

	//Secret Informer
	secretInf := cache.NewSharedIndexInformer(
		&cache.ListWatch{
			ListFunc: func(options metav1.ListOptions) (runtime.Object, error) {
				return coreV1.Secrets(metav1.NamespaceAll).List(ctx, options)
			},
			WatchFunc: func(options metav1.ListOptions) (watch.Interface, error) {
				return coreV1.Secrets(metav1.NamespaceAll).Watch(ctx, options)
			},
		},
		&corev1.Secret{},
		0,
		cache.Indexers{cache.NamespaceIndex: cache.MetaNamespaceIndexFunc},
	)

	serviceInf := cache.NewSharedIndexInformer(
		&cache.ListWatch{
			ListFunc: func(options metav1.ListOptions) (runtime.Object, error) {
				return coreV1.Services(metav1.NamespaceAll).List(ctx, options)
			},
			WatchFunc: func(options metav1.ListOptions) (watch.Interface, error) {
				return coreV1.Services(metav1.NamespaceAll).Watch(ctx, options)
			},
		},
		&corev1.Service{},
		0,
		cache.Indexers{cache.NamespaceIndex: cache.MetaNamespaceIndexFunc},
	)

	return &Watch{
		ctx:                     ctx,
		client:                  cl,
		deploymentInf:           deploymentInf,
		daemonSetInf:            daemonSetInf,
		statefulSetInf:          statefulSetInf,
		configMapInf:            configMapInf,
		secretInf:               secretInf,
		serviceInf:              serviceInf,
		updatedRes:              map[string]bool{},
		checkRes:                checkRes,
		lock:                    sync.RWMutex{},
		watchIntervalSecs:       35,
		addonChangeIntervalSecs: 15,
	}, nil
}

func readResourcesFile() (map[string]string, error) {
	watchConfig := WatchConfig{}

	content, err := ioutil.ReadFile(resourceFile)
	if err != nil {
		log.Errorf("Failed to read resources file %s %s", resourceFile, err)
		return nil, err
	}

	if err = yaml.Unmarshal(content, &watchConfig); err != nil {
		return nil, err
	}

	return watchConfig.Resources, nil
}

// Run starts sync workers
func (w *Watch) Run(stopc <-chan struct{}) error {

	go w.worker()

	go w.deploymentInf.Run(stopc)
	go w.daemonSetInf.Run(stopc)
	go w.statefulSetInf.Run(stopc)
	go w.configMapInf.Run(stopc)
	go w.secretInf.Run(stopc)
	go w.serviceInf.Run(stopc)

	if err := w.waitForCacheSync(stopc); err != nil {
		return err
	}

	w.addHandlers()
	select {
	case <-stopc:
		return nil
	}
	return nil
}

func keyFunc(obj interface{}) (string, bool) {
	k, err := cache.DeletionHandlingMetaNamespaceKeyFunc(obj)
	if err != nil {
		log.Error(err, "creating key failed")
		return "", false
	}

	return k, true
}

func (w *Watch) addResource(key string) {

	// Check if we are supposed to watch this resource
	addonType, ok := w.checkRes[key]
	if !ok {
		return
	}

	lock.Lock()
	// Has this resources been recently updated by the Addon operator
	ts, ok := addonDetails[addonType]
	lock.Unlock()

	if ok && time.Now().Unix()-ts < w.addonChangeIntervalSecs {
		log.Debugf("Watch: addon of type %s changed through Addon object, ignoring update", addonType)
		return
	}

	w.lock.Lock()
	// In case of multiple resources are manually updated by the user, merge all such notifications here,
	// so can trigger the Addon update just once to ensure a reconcile to original values.
	w.updatedRes[addonType] = true
	w.lock.Unlock()
	log.Infof("Watch: Resources for addon of type %s changed manually", addonType)
}

func (w *Watch) enqueue(obj interface{}) {
	if obj == nil {
		return
	}

	key, ok := obj.(string)
	if !ok {
		key, ok = keyFunc(obj)
		if !ok {
			return
		}
	}
	w.addResource(key)
}

func (w *Watch) worker() {

	for {

		time.Sleep(time.Duration(w.watchIntervalSecs) * time.Second)

		if len(w.updatedRes) == 0 {
			continue
		}

		addons := []string{}
		w.lock.Lock()
		for k := range w.updatedRes {
			addons = append(addons, k)
		}
		w.lock.Unlock()

		for _, k := range addons {
			log.Infof("Watch: Processing addon type: %s", k)
			w.updateAddon(k)
		}

		w.lock.Lock()
		for _, k := range addons {
			delete(w.updatedRes, k)
		}
		w.lock.Unlock()

	}

}

// waitForCacheSync waits for the informers' caches to be synced.
func (w *Watch) waitForCacheSync(stopc <-chan struct{}) error {
	ok := true
	informers := []struct {
		name     string
		informer cache.SharedIndexInformer
	}{
		{"Deployment", w.deploymentInf},
		{"Daemonsets", w.daemonSetInf},
		{"StatefulSets", w.statefulSetInf},
		{"Configmaps", w.configMapInf},
		{"Secrets", w.secretInf},
		{"Services", w.serviceInf},
	}

	for _, inf := range informers {
		if !cache.WaitForCacheSync(stopc, inf.informer.HasSynced) {
			log.Errorf("failed to sync %s cache", inf.name)
			ok = false
		} else {
			log.Debugf("successfully synced %s cache", inf.name)
		}
	}
	if !ok {
		return errors.New("failed to sync caches")
	}
	log.Info("Watch: successfully synced all caches")
	return nil
}

func (w *Watch) addHandlers() {
	w.deploymentInf.AddEventHandler(cache.ResourceEventHandlerFuncs{
		UpdateFunc: func(old, cur interface{}) {
			w.handleDeployUpdate(cur)
		},
		DeleteFunc: func(obj interface{}) {
			w.handleDeployUpdate(obj)
		},
	})
	w.daemonSetInf.AddEventHandler(cache.ResourceEventHandlerFuncs{
		UpdateFunc: func(old, cur interface{}) {
			w.handleDaemonsetUpdate(cur)
		},
		DeleteFunc: func(obj interface{}) {
			w.handleDaemonsetUpdate(obj)
		},
	})
	w.statefulSetInf.AddEventHandler(cache.ResourceEventHandlerFuncs{
		UpdateFunc: func(old, cur interface{}) {
			w.handleSfsUpdate(cur)
		},
		DeleteFunc: func(obj interface{}) {
			w.handleSfsUpdate(obj)
		},
	})
	w.configMapInf.AddEventHandler(cache.ResourceEventHandlerFuncs{
		UpdateFunc: func(old, cur interface{}) {
			w.handleCfgMapUpdate(cur)
		},
		DeleteFunc: func(obj interface{}) {
			w.handleCfgMapUpdate(obj)
		},
	})
	w.secretInf.AddEventHandler(cache.ResourceEventHandlerFuncs{
		UpdateFunc: func(old, cur interface{}) {
			w.handleSecretUpdate(cur)
		},
		DeleteFunc: func(obj interface{}) {
			w.handleSecretUpdate(obj)
		},
	})
	w.serviceInf.AddEventHandler(cache.ResourceEventHandlerFuncs{
		UpdateFunc: func(old, cur interface{}) {
			w.handleServiceUpdate(cur)
		},
		DeleteFunc: func(obj interface{}) {
			w.handleServiceUpdate(obj)
		},
	})

}

func (w *Watch) handleDeployUpdate(obj interface{}) {
	key, ok := keyFunc(obj)
	if !ok {
		return
	}

	log.Debugf("Watch: Deployment updated: %s", key)

	w.enqueue("deployment/" + key)
}

func (w *Watch) handleDaemonsetUpdate(obj interface{}) {
	key, ok := keyFunc(obj)
	if !ok {
		return
	}

	log.Debugf("Watch: Daemonset updated: %s", key)

	w.enqueue("daemonset/" + key)
}

func (w *Watch) handleSfsUpdate(obj interface{}) {
	key, ok := keyFunc(obj)
	if !ok {
		return
	}

	log.Debugf("Watch: Statefulset updated: %s", key)

	w.enqueue("statefulset/" + key)
}

func (w *Watch) handleCfgMapUpdate(obj interface{}) {
	key, ok := keyFunc(obj)
	if !ok {
		return
	}

	log.Debugf("Watch: Configmap updated: %s", key)

	w.enqueue("configmap/" + key)
}

func (w *Watch) handleSecretUpdate(obj interface{}) {
	key, ok := keyFunc(obj)
	if !ok {
		return
	}

	log.Debugf("Watch: Secret updated: %s", key)

	w.enqueue("secret/" + key)
}

func (w *Watch) handleServiceUpdate(obj interface{}) {
	key, ok := keyFunc(obj)
	if !ok {
		return
	}

	log.Debugf("Watch: Service updated: %s", key)

	w.enqueue("service/" + key)
}

func (w *Watch) updateAddon(addonType string) {

	ctx := context.Background()
	addon := &agentv1.Addon{}
	name := clusterID + "-" + addonType
	err := w.client.Get(ctx,
		types.NamespacedName{
			Name:      name,
			Namespace: "pf9-addons",
		}, addon)
	if err != nil {
		log.Errorf("Failed to get addon: %s %s", name, err)
		return
	}

	// If the watch fiels in Addon spec is false the user no longer wants us to watch deployed resources,
	// ignore notifications even if the user manually changes any resource
	if !addon.Spec.Watch {
		log.Infof("Watch: addon: %s is not configured to watch for resources, ignoring update", name)
		return
	}

	if !addon.GetDeletionTimestamp().IsZero() {
		log.Infof("Watch: addon: %s is being deleted, ignoring update", name)
		return
	}

	if addon.Status.Phase != v1alpha2.AddonPhaseInstalled {
		log.Infof("Watch: addon: %s is not installed, ignoring update", name)
		return
	}

	if addon.ObjectMeta.Generation != addon.Status.ObservedGeneration {
		log.Infof("Watch: addon: %s has already changed, ignoring update", name)
		return
	}

	// The addon reconcile loop interprets a valid change in Addon spec when
	// generation number > observed generation number. For e.g. when the health check loop updates
	// the status of the Addon object, the generation number is not incremented, and that's how
	// the Addon Reconcile loop knows that this change should be ignored. Using that here, to
	// trigger off a reconcile for the Addon, by reducing the observed generation number.
	// See the Reconcile loop and how it uses observed generation number for more details.
	addon.Status.ObservedGeneration = addon.Status.ObservedGeneration - 1

	err = w.client.Status().Update(ctx, addon)
	if err != nil {
		log.Errorf("Watch: Failed to update addon: %s %s", name, err)
	}

	log.Infof("Watch: Triggered update of addon: %s", name)
}
